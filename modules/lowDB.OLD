

    const low = require('lowdb'),
          FileSync = require('lowdb/adapters/FileSync'),
          adapter = new FileSync('db.json'),
          db = low(adapter),
          sha2_256 = require('simple-js-sha2-256')

    db._.mixin({



    })

    const functions = {

        createCollection:(collection) => {

            return new Promise(async (resolve, reject) => {

                let exists = db.has(collection).value()

                if (exists){

                } else {
                    let new_collection = await db.set(collection, []).write()
                }

                resolve([])

            })

        },

        read: async (collection, data) => {

                this.result = await db.get(collection)
                      .value()

                return {

                    orWhere: function(filters) {

                        this.result = this.result.filter((o) => {

                            let match = false

                            filters.map((op) => {

                                if (op[2]){ // if middle item is operator

                                    if (op[1] == '==' && o[op[0]] == op[2]){
                                        match = true
                                    } else if (op[1] == '!=' && o[op[0]] != op[2]){
                                        match = true
                                    } else if (op[1] == '>' && o[op[0]] > op[2]){
                                        match = true
                                    } else if (op[1] == '>=' && o[op[0]] >= op[2]){
                                        match = true
                                    } else if (op[1] == '<' && o[op[0]] < op[2]){
                                        match = true
                                    } else if (op[1] == '<=' && o[op[0]] <= op[2]){
                                        match = true
                                    } else if (op[1].match(/^like/i)){

                                        let re = new RegExp(op[2],'i')

                                        if (o[op[0]] && o[op[0]].match(re)){
                                            match = true
                                        }

                                    } else if (op[1].match(/^not\s*like/i)){

                                        let re = new RegExp(op[2],'i')

                                        if (!o[op[0]] || !o[op[0]].match(re)){
                                            match = true
                                        }

                                    }

                                } else {

                                    if (o[op[0]] == op[1]){
                                        match = true
                                    }

                                }


                            })

                            return match

                        })

                        return this

                    },

                    where: function(filters) {

                        this.result = this.result.filter((o) => {

                            let match = false,
                                match_count = 0

                            filters.map((op) => {

                                if (op[2]){ // if middle item is operator

                                    if (op[1] == '==' && o[op[0]] == op[2]){
                                        match_count++
                                    } else if (op[1] == '!=' && o[op[0]] != op[2]){
                                        match_count++
                                    } else if (op[1] == '>' && o[op[0]] > op[2]){
                                        match_count++
                                    } else if (op[1] == '>=' && o[op[0]] >= op[2]){
                                        match_count++
                                    } else if (op[1] == '<' && o[op[0]] < op[2]){
                                        match_count++
                                    } else if (op[1] == '<=' && o[op[0]] <= op[2]){
                                        match_count++
                                    } else if (op[1].match(/^like/i)){

                                        let re = new RegExp(op[2],'i')

                                        if (o[op[0]] && o[op[0]].match(re)){
                                            match_count++
                                        }

                                    } else if (op[1].match(/^not\s*like/i)){

                                        let re = new RegExp(op[2],'i')

                                        if (!o[op[0]] || !o[op[0]].match(re)){
                                            match_count++
                                        }

                                    }

                                } else {

                                    if (o[op[0]] == op[1]){
                                        match_count++
                                    }

                                }

                                if (filters.length === match_count) {
                                    match = true
                                }

                            })

                            return match

                        })

                        return this

                    },

                    value(){

                        return new Promise(async (resolve, reject) => {
                            if (this.result.length > 0){
                                resolve(this.result)
                            } else {
                                reject('Not found')
                            }
                        })

                    }

                }

        },

        update:(collection, data, payload) => {

            return new Promise(async (resolve, reject) => {

                if (payload){

                    payload._updated = moment().toISOString()

                    let result = await db.get(collection)
                      .filter(data)
                      .value()

                     result = result.map((item,i) => {

                         item = Object.assign(item, payload)
                         functions.update(collection, item)
                         return item

                     })

                    resolve(result)

                } else if (data._key || data._key == 0){

                    data._updated = moment().toISOString()

                    let result = await db.get(collection)
                      .find({_key: data._key})
                      .assign(data)
                      .write()

                    resolve(result)

                } else {

                    reject('Unable to update, no key included')

                }

            })

        },

        create:(collection, data) => {

            return new Promise(async (resolve, reject) => {

                let exists = await functions.createCollection(collection)

                let new_key = await db.get(collection).size().value()

                data._id = collection+'/'+new_key
                data._key = new_key
                data._created = moment().toISOString()

                let result = await db.get(collection).push(data).write()

                resolve(result)

            })

        },

        delete:(collection, data) => {

            return new Promise(async (resolve, reject) => {

                if (data._key && data.trash === true){

                    delete data.trash
                    data._updated = moment().toISOString()
                    data._deleted = moment().toISOString()

                    await db.get(collection)
                      .find({ _key: parseInt(data._key) })
                      .assign(data)
                      .write()

                    resolve(data)

                } else if (data._key && data.trash === false){

                    delete data.trash
                    delete data._deleted
                    data._updated = moment().toISOString()

                    await db.get(collection)
                      .find({ _key: parseInt(data._key) })
                      .assign(data)
                      .write()

                    resolve(data)

                } else if (data._key || data._key == 0){

                    await db.get(collection)
                      .remove({ _key: parseInt(data._key) })
                      .write()

                    resolve(data)

                } else if (typeof data != 'object'){

                    let result = await db.get(collection)
                      .remove({ _key: parseInt(data) })
                      .write()

                    resolve(data)

                } else {

                    reject('Unable to delete, no key included')

                }

            })

        },

        upsert:(collection, data) => {

            return new Promise(async (resolve, reject) => {

                let result

                if (data._key || data._key == 0){

                    result = await functions.read(collection, {_key: data._key})

                    if (result){

                        functions.update(collection, data).then((data)=>{
                            resolve(data)
                        }).catch((err)=>{
                            reject(err)
                        })

                    } else {

                        functions.create(collection, data).then((data)=>{
                            resolve(data)
                        }).catch((err)=>{
                            reject(err)
                        })

                    }

                } else {

                    functions.create(collection, data).then((data)=>{
                        resolve(data)
                    }).catch((err)=>{
                        reject(err)
                    })

                }

            })

        },

        count:(collection, data) => {

            return new Promise(async (resolve, reject) => {

                if (data){
                    result = await db.get(collection)
                      .filter(data)
                      .size()
                      .value()
                } else {
                    result = await db.get(collection)
                      .size()
                      .value()
                }

                resolve(result)

            })

        },

        hash:(str)=>{
            return sha2_256(str)
        }

    }

    module.exports = functions
